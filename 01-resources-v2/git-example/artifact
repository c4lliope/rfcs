#!/usr/bin/env ruby

require "json"
require "rugged"
require "pry"
require "benchmark"

$request = JSON.parse(STDIN.read, symbolize_names: true)

# arbitrary number to limit memory usage; total commits to return at a time
# (across all branches)
CHECK_BATCH_LIMIT = 10000

def commit_version(c)
  {
    version: {ref: c.oid},
    metadata: [
      {name: "author", value: enc(c, c.author[:name])},
      {name: "author_date", value: c.author[:time].to_s},
      {name: "committer", value: enc(c, c.committer[:name])},
      {name: "committer_date", value: c.committer[:time].to_s},
      {name: "message", value: enc(c, c.message)}
    ]
  }
end

def bench(label, &blk)
  time = Benchmark.realtime(&blk)
  $stderr.puts "#{label}: #{time}s"
end

def enc(c, str)
  str = str.force_encoding("ISO-8859-1") unless c.header_field("Encoding")
  str.encode("UTF-8")
end

case ARGV[0]
when "check"
  # # booklit (~10 branches, ~200 commits)
  # $request = {
  #   config: {uri: "https://github.com/vito/booklit"},
  #   from: {
  #     master: {ref: "40bc6986197e411471d306bb8eb3a21c5b5f9d26"},
  #     travis: {ref: "8b0a526e233b1599f8d5fcc1179e0ec7642acd90"},
  #     circleci: {ref: "deadbeef"}, # bogus; simulate `push -f`
  #     wercker: {ref: "092dbc7b001c47d9aac8c59f9cadd04dcba7e963"},
  #     jenkins: {ref: "092dbc7b001c47d9aac8c59f9cadd04dcba7e963"}
  #   }
  # }

  # # concourse (~15 branches, ~8500 commits)
  # $request = {
  #   config: {uri: "https://github.com/concourse/concourse"},
  #   from: {}
  # }

  # # rails (~36 branches, ~70k commits)
  # $request = {
  #   config: {uri: "https://github.com/rails/rails"},
  #   from: {}
  # }

  # # linux (~2 branches, ~766k commits)
  # $request = {
  #   config: {uri: "https://github.com/torvalds/linux"},
  #   from: {
  #     master: {ref: "81e97f01371f4e1701feeafe484665112cd9ddc2"},
  #     "proc-cmdline": {ref: "7a1e335085ead05da08f791340f58b493126894d"}
  #   }
  # }

  repo_dir = File.basename($request[:config][:uri])

  repo =
    if Dir.exists?(repo_dir)
      Rugged::Repository.new(repo_dir).tap do |r|
        r.fetch("origin")
      end
    else
      Rugged::Repository.clone_at(
        $request[:config][:uri],
        repo_dir,
        bare: true,
        progress: lambda { |t| print t })
    end

  spaces = []
  default_branch = nil

  total_commits = 0

  repo.branches.each do |b|
    if b.remote?
      space_name = b.name.sub("#{b.remote_name}/", "")

      has_latest = false
      commits = []

      walker = Rugged::Walker.new(repo)
      walker.sorting(Rugged::SORT_TOPO|Rugged::SORT_REVERSE)
      walker.simplify_first_parent
      walker.push(b.target)

      from = $request[:from][space_name.to_sym]

      if from && repo.include?(from[:ref])
        commit = repo.lookup(from[:ref])
        walker.hide(commit)

        commits << commit_version(commit)
        total_commits += 1
        has_latest = commit.oid == b.target.oid
      end

      unless has_latest || total_commits >= CHECK_BATCH_LIMIT
        bench("#{space_name} walk") do
          walker.walk do |c|
            # TODO: test if commit satisfies paths/ignore_paths
            commits << commit_version(c)
            total_commits += 1
            has_latest = c.oid == b.target.oid

            break if total_commits >= CHECK_BATCH_LIMIT
          end
        end
      end

      next if commits.empty?

      $stderr.puts "#{space_name} commits: #{commits.size} (latest: #{has_latest})"

      spaces << {
        space: space_name,
        versions: commits,
        has_latest: has_latest
      }
    else
      # assume the only local branch is the default one
      default_branch = b.name
    end
  end

  bench("dump") do
    puts JSON.dump({
      spaces: spaces,
      default_space: default_branch
    })
  end

when "get"
  $request = {
    config: {uri: "https://github.com/vito/booklit"},
    space: "master",
    version: {ref: "f828f2758256b0e93dc3c101f75604efe92ca07e"}
  }

  repo =
    Rugged::Repository.clone_at(
      $request[:config][:uri],
      "dot", # TODO: irl this would be '.'
      checkout_branch: $request[:space])

  repo.checkout($request[:version][:ref])

  # TODO: update/init submodules recursively

  # TODO: draw the rest of the owl
  #
  # most of this is uninteresting.

when "put"
  puts "putting"
end
