#!/usr/bin/env ruby

require "json"
require "rugged"
require "pry"
require "benchmark"

$request = JSON.parse(STDIN.read, symbolize_names: true)

# arbitrary number to limit memory usage; total commits to return at a time
# (across all branches)
CHECK_BATCH_LIMIT = 10000

def commit_version(c)
  {
    version: {ref: c.oid},
    metadata: [
      {name: "author", value: enc(c, c.author[:name])},
      {name: "author_date", value: c.author[:time].to_s},
      {name: "committer", value: enc(c, c.committer[:name])},
      {name: "committer_date", value: c.committer[:time].to_s},
      {name: "message", value: enc(c, c.message)}
    ]
  }
end

def bench(label, &blk)
  time = Benchmark.realtime(&blk)
  $stderr.puts "#{label}: #{time}s"
end

def enc(c, str)
  str = str.force_encoding("ISO-8859-1") unless c.header_field("Encoding")
  str.encode("UTF-8")
end

case ARGV[0]
when "check"
  repo_dir = File.basename($request[:config][:uri])

  repo =
    if Dir.exists?(repo_dir)
      Rugged::Repository.new(repo_dir).tap do |r|
        r.fetch("origin")
      end
    else
      Rugged::Repository.clone_at(
        $request[:config][:uri],
        repo_dir,
        bare: true,
        progress: lambda { |t| print t })
    end

  spaces = []
  default_branch = nil

  total_commits = 0

  repo.branches.each do |b|
    unless b.remote?
      # assume the only local branch is the default one
      default_branch = b.name
      next
    end

    space_name = b.name.sub("#{b.remote_name}/", "")

    has_latest = false
    commits = []

    walker = Rugged::Walker.new(repo)
    walker.sorting(Rugged::SORT_TOPO|Rugged::SORT_REVERSE)
    walker.simplify_first_parent
    walker.push(b.target)

    from = $request[:from][space_name.to_sym]

    if from && repo.include?(from[:ref])
      commit = repo.lookup(from[:ref])
      walker.hide(commit)

      commits << commit_version(commit)
      total_commits += 1
      has_latest = commit.oid == b.target.oid
    end

    unless has_latest || total_commits >= CHECK_BATCH_LIMIT
      bench("#{space_name} walk") do
        walker.walk do |c|
          # TODO: test if commit satisfies paths/ignore_paths
          commits << commit_version(c)
          total_commits += 1
          has_latest = c.oid == b.target.oid

          break if total_commits >= CHECK_BATCH_LIMIT
        end
      end
    end

    next if commits.empty?

    $stderr.puts "#{space_name} commits: #{commits.size} (latest: #{has_latest})"

    spaces << {
      space: space_name,
      versions: commits,
      has_latest: has_latest
    }
  end

  bench("dump") do
    puts JSON.dump({
      spaces: spaces,
      default_space: default_branch
    })
  end

when "get"
  $request = {
    config: {uri: "https://github.com/vito/booklit"},
    space: "master",
    version: {ref: "f828f2758256b0e93dc3c101f75604efe92ca07e"}
  }

  repo =
    Rugged::Repository.clone_at(
      $request[:config][:uri],
      "dot", # TODO: irl this would be '.'
      checkout_branch: $request[:space])

  repo.checkout($request[:version][:ref])

  # TODO: update/init submodules recursively

  # TODO: draw the rest of the owl
  #
  # most of this is uninteresting.

when "put"
  puts "putting"
end
